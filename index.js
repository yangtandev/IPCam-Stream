/* 
    Express.js & Node.js
*/
const { spawn } = require('child_process');
// const http = require('https'); // HTTP
const https = require('https'); // HTTPS
const fs = require('fs');
const options = {
	key: fs.readFileSync(
		`/etc/letsencrypt/live/stream.ginibio.com/privkey.pem`,
		'utf8'
	),
	cert: fs.readFileSync(
		`/etc/letsencrypt/live/stream.ginibio.com/fullchain.pem`,
		'utf8'
	),
}; // HTTPS
const express = require('express');
const cors = require('cors');
const app = express();
// const server = http.createServer(app); // HTTP
const server = https.createServer(options, app); // HTTPS
const port = 3000;

/* 
    Variables
*/
const config = {};
const rtmpCommands = {};
const rtspCommands = {};
const mp4Commands = {};

/*
    Paths
*/
const pm2Path = `$HOME/.nvm/versions/node/v14.16.1/bin/pm2`;
const backupPath = `./ZLMediaKit/release/linux/Debug/www`;
const clientListPath = `./ZLMediaKit/release/linux/Debug/www/client-list/client-list.json`;
const ffmpeg = require('fluent-ffmpeg');
ffmpeg.setFfmpegPath(`./nvidia/ffmpeg/ffmpeg`);

/*
    Convert the original RTMP stream to RTSP stream.
*/
function RTMPToRTSP(rtmp) {
	const id = rtmp.split('/').pop();
	const rtsp = `rtsp://localhost:9554/live/${id}`;

	if (rtmpCommands.hasOwnProperty(id)) {
		rtmpCommands[id].kill('SIGKILL');
	}

	rtmpCommands[id] = ffmpeg(rtmp);
	rtmpCommands[id]
		.addInputOption()
		.addOutputOption(
			'-fps_mode',
			'passthrough',
			'-rtsp_transport',
			'tcp',
			'-preset',
			'medium',
			'-movflags',
			'faststart',
			'-threads',
			2
		)
		.output(rtsp)
		.outputFormat('rtsp')
		.videoCodec('h264_nvenc')
		.noAudio()
		.on('stderr', function (err) {
			if (
				err.includes('muxing overhead: unknown') ||
				err.includes('Error muxing a packet')
			) {
				RTMPToRTSP(rtmp);
				RTSPToMP4(rtsp);
			}
		})
		.on('error', function (err, stdout, stderr) {
			if (
				// err.message.includes('5XX Server Error reply') ||
				// err.message.includes('Connection refused') ||
				// err.message.includes('Conversion failed') ||
				err.message.includes('Connection timed out') ||
				err.message.includes('No route to host') ||
				err.message.includes(
					'Invalid data found when processing input'
				) ||
				err.message.includes('Generic error in an external library')
			) {
				RTMPToRTSP(rtmp);
				RTSPToMP4(rtsp);
			}
		})
		.on('end', function () {
			RTMPToRTSP(rtmp);
		})
		.run();
}

/*
    Convert the original RTSP stream to a format acceptable to Media Server.
*/
function RTSPToRTSP(rtsp, type) {
	const ip = rtsp.split('@').pop().split('/').shift();
	const id = ip.match(/\d+/g);
	const output = `rtsp://localhost:9554/live/${ip}`;

	if (rtspCommands.hasOwnProperty(id)) {
		rtspCommands[id].kill('SIGKILL');
	}

	rtspCommands[id] = ffmpeg(rtsp);
	rtspCommands[id]
		.addInputOption(
			'-rtsp_transport',
			'tcp',
			'-re',
			'-hwaccel',
			'cuda',
			'-hwaccel_output_format',
			'cuda',
			'-c:v',
			`${type}_cuvid`
		)
		.addOutputOption(
			'-fps_mode',
			'passthrough',
			'-rtsp_transport',
			'tcp',
			'-preset',
			'medium',
			'-movflags',
			'faststart',
			'-threads',
			2
		)
		.output(output)
		.outputFormat('rtsp')
		.videoCodec('h264_nvenc')
		.noAudio()
		.on('stderr', function (err) {
			if (ip == '192.168.31.133:554') {
				// if (
				// 	!(
				// 		err.includes('frame=') ||
				// 		err.includes('Non-monotonous DTS')
				// 	)
				// ) {
				// console.log('stderr', ip, err);
				// }
			}
			if (
				err.includes('muxing overhead: unknown') ||
				err.includes('Error muxing a packet')
			) {
				RTSPToRTSP(rtsp, type);
				RTSPToMP4(rtsp);
			}
		})
		.on('error', function (err, stdout, stderr) {
			console.log('error', ip, err.message);

			if (
				// err.message.includes('5XX Server Error reply') ||
				// err.message.includes('Connection refused') ||
				// err.message.includes('Conversion failed') ||
				err.message.includes('Connection timed out') ||
				err.message.includes('No route to host') ||
				err.message.includes(
					'Invalid data found when processing input'
				) ||
				err.message.includes('Generic error in an external library')
			) {
				RTSPToRTSP(rtsp, type);
				RTSPToMP4(rtsp);
			}
		})
		.on('end', function () {
			console.log('192.168.31.133:554', 'end');
			RTSPToRTSP(rtsp, type);
		})
		.run();
}

/*
    Capture the MP4 stream generated by the Media Server and store it in the specified location.
*/
function RTSPToMP4(rtsp) {
	const ip = rtsp.includes('@')
		? rtsp.split('@').pop().split('/').shift()
		: rtsp.split('/').pop();

	const id = ip.includes(':') ? ip.match(/\d+/g) : ip;
	const { clientName } = config.clientList.find((client) => {
		if (client.rtspList) {
			return client.rtspList.includes(rtsp);
		} else if (client.rtmpList) {
			return client.rtmpList
				.map((rtmp) => rtmp.split('/').pop())
				.includes(id);
		}
	});

	const input = `rtsp://localhost:9554/live/${ip}`;
	const now = new Date(
		new Date().getTime() - new Date().getTimezoneOffset() * 60000 + 13000
	);
	const today = now.toISOString().replace(/\:+/g, '-').slice(0, 10);
	const fileName = now.toISOString().slice(0, -5).split('T').join(' ');
	let output = backupPath;

	for (let path of [clientName, 'backup', today, ip]) {
		output += `/${path}`;
		if (!fs.existsSync(output)) {
			fs.mkdirSync(output);
		}
	}

	output += `/${fileName}.mp4`;

	if (mp4Commands.hasOwnProperty(id)) {
		mp4Commands[id].kill();
	}

	mp4Commands[id] = ffmpeg(input);
	mp4Commands[id]
		.addInputOption(
			'-rtsp_transport',
			'tcp',
			'-use_wallclock_as_timestamps',
			1,
			'-ss',
			0,
			'-to',
			300
		)
		.addOutputOption(
			'-fps_mode',
			'passthrough',
			'-preset',
			'medium',
			'-movflags',
			'faststart',
			'-avoid_negative_ts',
			'make_zero',
			'-threads',
			2
		)
		.videoCodec('h264_nvenc')
		.noAudio()
		.on('start', function (commandLine) {})
		.on('stderr', function (err) {
			if (err.includes('Error submitting video frame to the encoder')) {
				RTSPToMP4(rtsp);
			}
		})
		.on('error', function (err, stdout, stderr) {
			if (
				// err.message.includes('Connection refused')||
				// err.message.includes('Server returned 404 Not Found') ||
				err.message.includes('Conversion failed')
			) {
				RTSPToMP4(rtsp);
			}
		})
		.on('end', function () {
			RTSPToMP4(rtsp);
		})
		.save(output);
}

/*
    Set rtsp list related variables.
*/
function setRtspList() {
	const source = JSON.parse(fs.readFileSync(clientListPath, 'utf8'));
	const typeList = ['rtmp', 'h264Rtsp', 'hevcRtsp'];
	config[`clientList`] = [];

	typeList.forEach((type) => {
		config[`${type}ClientList`] = source[`${type}ClientList`];
		config[`clientList`] = config[`clientList`].concat(
			config[`${type}ClientList`]
		);

		if (config[`${type}ClientList`].length > 0) {
			config[`${type}List`] = config[`${type}ClientList`]
				.map((client) => {
					if (client[`rtspList`]) return client[`rtspList`];
					if (client[`rtmpList`]) return client[`rtmpList`];
				})
				.reduce((prev, curr) => prev.concat(curr));
		} else {
			config[`${type}ClientList`] = [];
			config[`${type}List`] = [];
		}
	});

	config.allRtspList = []
		.concat(config.h264RtspList)
		.concat(config.hevcRtspList);
}

/*
    Periodically clear backups that are one month overdue.
*/
function clearExpiredBackup() {
	const clientList = config[`clientList`].map((client) => client.clientName);
	const expireLimitDays = 30;
	for (const client of clientList) {
		fs.readdir(`${backupPath}/${client}/backup`, (err, dates) => {
			if (err) throw err;

			dates.forEach((date) => {
				const now = new Date(
					new Date().getTime() -
						new Date().getTimezoneOffset() * 60000
				);
				const currentDate = now
					.toISOString()
					.replace(/\:+/g, '-')
					.slice(0, 10);
				let dateDiff = parseInt(
					Math.abs(new Date(currentDate) - new Date(date)) /
						1000 /
						60 /
						60 /
						24
				);

				if (dateDiff > expireLimitDays)
					fs.rmSync(`${backupPath}/${client}/backup/${date}`, {
						recursive: true,
						force: true,
					});
			});
		});
	}
}

/*
    Run all necessary processes.
*/
function runProcesses() {
	if (config.rtmpList.length > 0) {
		config.rtmpList.forEach((rtmp) => {
			const id = rtmp.split('/').pop();
			const rtsp = `rtsp://localhost:9554/live/${id}`;
			RTMPToRTSP(rtmp);
			RTSPToMP4(rtsp);
		});
	}

	if (config.h264RtspList.length > 0) {
		config.h264RtspList.forEach((rtsp) => {
			RTSPToRTSP(rtsp, 'h264');
			RTSPToMP4(rtsp);
		});
	}

	if (config.hevcRtspList.length > 0) {
		config.hevcRtspList.forEach((rtsp) => {
			RTSPToRTSP(rtsp, 'hevc');
			RTSPToMP4(rtsp);
		});
	}
}

app.use(cors());
app.use(express.json());
app.use(express.static(__dirname));

app.get(
	'/forceReloadSystem',
	cors('https://stream.ginibio.com/'),
	(req, res) => {
		try {
			// Force reload main process.
			spawn(`${pm2Path} reload nvr --force`, { shell: true });

			res.send('success');
		} catch (err) {
			console.log(err);

			res.send(err.message);
			return;
		}
	}
);

app.post(
	'/updateClientList',
	cors('https://stream.ginibio.com/'),
	(req, res) => {
		const { data } = req.body;
		try {
			JSON.parse(data);
			fs.writeFile(clientListPath, data, (err) => {
				if (err) throw err;

				// Terminate all processes related to ffmpeg, media server and zombie processes.
				const killFFMPEG = spawn('killall -9 ffmpeg', { shell: true });

				const killZombieProcesses = spawn(
					`ps -Al | grep -w Z | awk '{print $4}' | xargs sudo kill -9`,
					{ shell: true }
				);

				setRtspList();
				runProcesses();
			});
			res.send('success');
		} catch (err) {
			res.send(err.message);
			return;
		}
	}
);

app.post('/reloadFFmpeg', cors('https://stream.ginibio.com/'), (req, res) => {
	const { data } = req.body;
	console.log(data);
	try {
		[`h264`, `hevc`].forEach((type) => {
			const rtsp = config[`${type}RtspList`]
				.filter(
					(rtsp) =>
						rtsp
							.split('@')
							.pop()
							.split('/')
							.shift()
							.match(/\d/g)
							.join('') == data.match(/\d/g).join('')
				)
				.join(' ');

			if (rtsp) {
				// RTSP reconnection mechanism.
				RTSPToRTSP(rtsp, type);
				RTSPToMP4(rtsp);
			} else throw 'RTSP not found';
		});

		res.send('success');
	} catch (err) {
		res.send(err);
		return;
	}
});

server.listen(port, () => {
	setTimeout(() => {
		setRtspList();
		runProcesses();
		setInterval(clearExpiredBackup, 1000 * 60 * 5);
	}, 1000 * 10); // Buffer time reserved for reboot.
});

/* 
    When the program terminates, clear the related background programs.
*/
process.on('SIGINT', (code) => {
	String('SIGINT')
		.split('')
		.forEach((word) => {
			const slashes = String('|').repeat(30);
			console.log(`${slashes} ${word} ${slashes}`);
		});

	const killFFMPEG = spawn('killall -9 ffmpeg', { shell: true });

	const killZombieProcesses = spawn(
		`ps -Al | grep -w Z | awk '{print $4}' | xargs sudo kill -9`,
		{ shell: true }
	);
});
